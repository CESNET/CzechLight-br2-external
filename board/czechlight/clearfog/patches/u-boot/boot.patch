diff --git a/board/solidrun/clearfog/clearfog.c b/board/solidrun/clearfog/clearfog.c
index 4e1386c8a2..be54ae0b78 100644
--- a/board/solidrun/clearfog/clearfog.c
+++ b/board/solidrun/clearfog/clearfog.c
@@ -10,10 +10,15 @@
 #include <asm/io.h>
 #include <asm/arch/cpu.h>
 #include <asm/arch/soc.h>
+#include <dm/uclass.h>
 
 #include "../drivers/ddr/marvell/a38x/ddr3_init.h"
 #include <../serdes/a38x/high_speed_env_spec.h>
 
+#ifdef CONFIG_WDT_ORION
+# include <wdt.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #define ETH_PHY_CTRL_REG		0
@@ -108,11 +113,95 @@ int board_early_init_f(void)
 	return 0;
 }
 
+#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_WDT_ORION)
+static struct udevice *watchdog_dev = NULL;
+#endif
+
+#define TLC59XXX_REG_MODE1 0x00
+#define TLC59XXX_REG_MODE2 0x01
+#define TLC59XXX_REG_PWM(LED) (LED + 0x02)
+#define TLC59XXX_REG_GRPPWM 0x12
+#define TLC59XXX_REG_GRPFREQ 0x13
+#define TLC59XXX_REG_LEDOUT0 0x14
+#define TLC59XXX_REG_LEDOUT1 0x15
+#define TLC59XXX_REG_LEDOUT2 0x16
+#define TLC59XXX_REG_LEDOUT3 0x17
+#define TLC59XXX_CHIP_RESET_ADDR 0x6b
+#define TLC59XXX_RESET_BYTE_0 0xa5
+#define TLC59XXX_RESET_BYTE_1 0x5a
+#define CLA_LED_CHIP_ADDR 0x60
+#define CLA_LED_STATUS_RED 8
+#define CLA_LED_STATUS_GREEN 9
+#define CLA_LED_STATUS_BLUE 10
+
+struct cla_led_config {
+	u8 reg;
+	u8 val;
+};
+
+static struct cla_led_config led_reset_config[] = {
+	{ TLC59XXX_RESET_BYTE_0, TLC59XXX_RESET_BYTE_1 },
+};
+
+static struct cla_led_config led_config[] = {
+	{ TLC59XXX_REG_MODE1, 0x01 }, /* enable oscillator */
+	{ TLC59XXX_REG_MODE2, 0x20 }, /* DMBLINK */
+	{ TLC59XXX_REG_GRPPWM, 0x40 }, /* 25% duty cycle */
+	{ TLC59XXX_REG_GRPFREQ, 0x03 }, /* very fast blinking */
+	{ TLC59XXX_REG_PWM(CLA_LED_STATUS_RED), 0x80 }, /* 50% brightness */
+	{ TLC59XXX_REG_PWM(CLA_LED_STATUS_GREEN), 0x80 }, /* 50% brightness */
+	{ TLC59XXX_REG_PWM(CLA_LED_STATUS_BLUE), 0x80 }, /* 50% brightness */
+	{ TLC59XXX_REG_LEDOUT2, 0x3f }, /* LEDs #8, 9, 10: mode 0b11 -> group blinking */
+};
+
+int cla_setup_leds(void)
+{
+	struct udevice *bus, *dev;
+
+	if (uclass_get_device_by_seq(UCLASS_I2C, 1, &bus)) {
+		puts("Cannot find I2C bus for LEDs\n");
+		return 1;
+	}
+
+	if (i2c_get_chip(bus, TLC59XXX_CHIP_RESET_ADDR, 1, &dev)) {
+		puts("Cannot request I2C chip for SWRST\n");
+		return 1;
+	}
+	if (dm_i2c_write(dev, led_reset_config[0].reg, &led_reset_config[0].val, 1)) {
+		puts("LED reset failed\n");
+		return 1;
+	}
+
+	if (i2c_get_chip(bus, CLA_LED_CHIP_ADDR, 1, &dev)) {
+		puts("Cannot request I2C chip for LEDs\n");
+		return 1;
+	}
+	for (int i = 0; i < ARRAY_SIZE(led_config); i++) {
+		if (dm_i2c_write(dev, led_config[i].reg, &led_config[i].val, 1)) {
+			printf("LED config operation #%d failed\n", i);
+			return 1;
+		}
+	}
+	return 0;
+}
+
 int board_init(void)
 {
 	/* Address of boot parameters */
 	gd->bd->bi_boot_params = mvebu_sdram_bar(0) + 0x100;
 
+#ifndef CONFIG_SPL_BUILD
+# ifdef CONFIG_WDT_ORION
+        if (uclass_get_device(UCLASS_WDT, 0, &watchdog_dev)) {
+                puts("Cannot find Armada 385 watchdog!\n");
+        } else {
+                puts("Enabling Armada 385 watchdog.\n");
+		/* one minute */
+                wdt_start(watchdog_dev, (u32) 25000000 * 60, 0);
+        }
+# endif
+#endif
+
 	/* Toggle GPIO41 to reset onboard switch and phy */
 	clrbits_le32(MVEBU_GPIO1_BASE + 0x0, BIT(9));
 	clrbits_le32(MVEBU_GPIO1_BASE + 0x4, BIT(9));
@@ -124,9 +213,33 @@ int board_init(void)
 	setbits_le32(MVEBU_GPIO0_BASE + 0x0, BIT(19));
 	mdelay(10);
 
+	cla_setup_leds();
+
 	return 0;
 }
 
+#ifdef CONFIG_WATCHDOG
+/* Called by macro WATCHDOG_RESET */
+void watchdog_reset(void)
+{
+# if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_WDT_ORION)
+        static ulong next_reset = 0;
+        ulong now;
+
+        if (!watchdog_dev)
+                return;
+
+        now = timer_get_us();
+
+        /* Do not reset the watchdog too often */
+        if (now > next_reset) {
+                wdt_reset(watchdog_dev);
+                next_reset = now + 1000;
+        }
+# endif
+}
+#endif
+
 int checkboard(void)
 {
 	puts("Board: SolidRun ClearFog\n");
diff --git a/configs/clearfog_defconfig b/configs/clearfog_defconfig
index 9167a9450d..faf06cb216 100644
--- a/configs/clearfog_defconfig
+++ b/configs/clearfog_defconfig
@@ -63,3 +63,5 @@ CONFIG_USB=y
 CONFIG_DM_USB=y
 CONFIG_USB_XHCI_HCD=y
 CONFIG_USB_STORAGE=y
+CONFIG_WDT=y
+CONFIG_WDT_ORION=y
diff --git a/include/configs/clearfog.h b/include/configs/clearfog.h
index 7d56dfd86e..c7697ad0f4 100644
--- a/include/configs/clearfog.h
+++ b/include/configs/clearfog.h
@@ -21,6 +21,14 @@
  * Commands configuration
  */
 
+/* Watchdog */
+#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_WDT_ORION)
+# define CONFIG_WATCHDOG
+#endif
+
+/* CzechLight: we have a 128kB EEPROM */
+#define CONFIG_SYS_EEPROM_SIZE		(128 * 1024)
+
 /* SPI NOR flash default params, used by sf commands */
 #define CONFIG_SF_DEFAULT_BUS		1
 
@@ -47,6 +55,9 @@
 #define CONFIG_ENV_OFFSET		0xf0000
 #define CONFIG_ENV_ADDR			CONFIG_ENV_OFFSET
 
+#define CONFIG_ENV_OFFSET_REDUND	0xe0000
+#define CONFIG_SYS_REDUNDAND_ENVIRONMENT
+
 #define PHY_ANEG_TIMEOUT	8000	/* PHY needs a longer aneg time */
 
 /* PCIe support */
@@ -139,14 +150,44 @@
 	"scriptaddr=" SCRIPT_ADDR_R "\0" \
 	"pxefile_addr_r=" PXEFILE_ADDR_R "\0"
 
-#include <config_distro_bootcmd.h>
-
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	RELOCATION_LIMITS_ENV_SETTINGS \
 	LOAD_ADDRESS_ENV_SETTINGS \
-	"fdtfile=" CONFIG_DEFAULT_DEVICE_TREE ".dtb\0" \
 	"console=ttyS0,115200\0" \
-	BOOTENV
+	"usbboot=usb start; fatload usb 0:1 ${scriptaddr} boot.scr; source ${scriptaddr}\0" \
+	"bootcmd=test -n \"${BOOT_A_LEFT}\" || setenv BOOT_A_LEFT 3;" \
+	"test -n \"${BOOT_B_LEFT}\" || setenv BOOT_B_LEFT 3;" \
+	"test -n \"${BOOT_ORDER}\" || setenv BOOT_ORDER \"A B\";" \
+	"for BOOT_SLOT in \"${BOOT_ORDER}\"; do" \
+	"  if test \"x${rauc_part}\" != \"x\"; then" \
+	"    ;" \
+	"  elif test \"x${BOOT_SLOT}\" = \"xA\"; then" \
+	"    if test ${BOOT_A_LEFT} -gt 0; then" \
+	"      setexpr BOOT_A_LEFT ${BOOT_A_LEFT} - 1;" \
+	"      echo \"Found valid slot A, ${BOOT_A_LEFT} attempts remaining\";" \
+	"      rauc_part=1;" \
+	"      rauc_slot=A;" \
+	"    fi;" \
+	"  elif test \"x${BOOT_SLOT}\" = \"xB\"; then" \
+	"    if test ${BOOT_B_LEFT} -gt 0; then" \
+	"      setexpr BOOT_B_LEFT ${BOOT_B_LEFT} - 1;" \
+	"      echo \"Found valid slot B, ${BOOT_B_LEFT} attempts remaining\";" \
+	"      rauc_part=3;" \
+	"      rauc_slot=B;" \
+	"    fi;" \
+	"  fi;" \
+	"done;" \
+	"if test -n \"${rauc_part}\"; then" \
+	"  saveenv ;" \
+	"else" \
+	"  echo \"No valid slot found, resetting tries to 3\";" \
+	"  setenv BOOT_A_LEFT 3;" \
+	"  setenv BOOT_B_LEFT 3;" \
+	"  saveenv;" \
+	"  reset;" \
+	"fi;" \
+	"load mmc 0:${rauc_part} ${scriptaddr} /boot/boot.scr || reset;" \
+	"source ${scriptaddr} || reset\0"
 
 #endif /* CONFIG_SPL_BUILD */
 
