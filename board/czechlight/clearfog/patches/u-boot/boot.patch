diff --git a/arch/arm/dts/armada-388-clearfog.dts b/arch/arm/dts/armada-388-clearfog.dts
index bc52bc0167..177cb4cd25 100644
--- a/arch/arm/dts/armada-388-clearfog.dts
+++ b/arch/arm/dts/armada-388-clearfog.dts
@@ -90,13 +90,10 @@
 		internal-regs {
 			ethernet@30000 {
 				mac-address = [00 50 43 02 02 02];
+				managed = "in-band-status";
+				phy = <&phy1>;
 				phy-mode = "sgmii";
 				status = "okay";
-
-				fixed-link {
-					speed = <1000>;
-					full-duplex;
-				};
 			};
 
 			ethernet@34000 {
@@ -228,6 +225,10 @@
 				pinctrl-0 = <&mdio_pins>;
 				pinctrl-names = "default";
 
+				phy1: ethernet-phy@1 { /* Marvell 88E1512 */
+					reg = <1>;
+				};
+
 				phy_dedicated: ethernet-phy@0 {
 					/*
 					 * Annoyingly, the marvell phy driver
@@ -384,62 +385,6 @@
 		tx-fault-gpio = <&expander0 13 GPIO_ACTIVE_HIGH>;
 	};
 
-	dsa@0 {
-		compatible = "marvell,dsa";
-		dsa,ethernet = <&eth1>;
-		dsa,mii-bus = <&mdio>;
-		pinctrl-0 = <&clearfog_dsa0_clk_pins &clearfog_dsa0_pins>;
-		pinctrl-names = "default";
-		#address-cells = <2>;
-		#size-cells = <0>;
-
-		switch@0 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			reg = <4 0>;
-
-			port@0 {
-				reg = <0>;
-				label = "lan1";
-			};
-
-			port@1 {
-				reg = <1>;
-				label = "lan2";
-			};
-
-			port@2 {
-				reg = <2>;
-				label = "lan3";
-			};
-
-			port@3 {
-				reg = <3>;
-				label = "lan4";
-			};
-
-			port@4 {
-				reg = <4>;
-				label = "lan5";
-			};
-
-			port@5 {
-				reg = <5>;
-				label = "cpu";
-			};
-
-			port@6 {
-				/* 88E1512 external phy */
-				reg = <6>;
-				label = "lan6";
-				fixed-link {
-					speed = <1000>;
-					full-duplex;
-				};
-			};
-		};
-	};
-
 	gpio-keys {
 		compatible = "gpio-keys";
 		pinctrl-0 = <&rear_button_pins>;
diff --git a/board/solidrun/clearfog/clearfog.c b/board/solidrun/clearfog/clearfog.c
index ede303d4eb..17bf27f875 100644
--- a/board/solidrun/clearfog/clearfog.c
+++ b/board/solidrun/clearfog/clearfog.c
@@ -10,10 +10,15 @@
 #include <asm/io.h>
 #include <asm/arch/cpu.h>
 #include <asm/arch/soc.h>
+#include <dm/uclass.h>
 
 #include "../drivers/ddr/marvell/a38x/ddr3_init.h"
 #include <../serdes/a38x/high_speed_env_spec.h>
 
+#ifdef CONFIG_WDT_ORION
+# include <wdt.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #define ETH_PHY_CTRL_REG		0
@@ -124,6 +129,54 @@ int board_early_init_f(void)
 	return 0;
 }
 
+#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_WDT_ORION)
+static struct udevice *watchdog_dev = NULL;
+#endif
+
+#define TLC59XXX_REG_MODE1 0x00
+#define TLC59XXX_REG_MODE2 0x01
+#define TLC59XXX_REG_PWM(LED) (LED + 0x02)
+#define TLC59XXX_REG_GRPPWM 0x12
+#define TLC59XXX_REG_GRPFREQ 0x13
+#define TLC59XXX_REG_LEDOUT0 0x14
+#define TLC59XXX_REG_LEDOUT1 0x15
+#define TLC59XXX_REG_LEDOUT2 0x16
+#define TLC59XXX_REG_LEDOUT3 0x17
+#define TLC59XXX_CHIP_RESET_ADDR 0x6b
+#define TLC59XXX_RESET_BYTE_0 0xa5
+#define TLC59XXX_RESET_BYTE_1 0x5a
+#define CLA_LED_CHIP_ADDR 0x60
+#define CLA_LED_STATUS_RED 8
+#define CLA_LED_STATUS_GREEN 9
+#define CLA_LED_STATUS_BLUE 10
+
+static struct marvell_io_exp led_config[] = {
+	{ TLC59XXX_CHIP_RESET_ADDR, TLC59XXX_RESET_BYTE_0, TLC59XXX_RESET_BYTE_1 },
+	{ CLA_LED_CHIP_ADDR, TLC59XXX_REG_MODE1, 0x01 }, /* enable oscillator */
+	{ CLA_LED_CHIP_ADDR, TLC59XXX_REG_MODE2, 0x20 }, /* DMBLINK */
+	{ CLA_LED_CHIP_ADDR, TLC59XXX_REG_GRPPWM, 0x40 }, /* 25% duty cycle */
+	{ CLA_LED_CHIP_ADDR, TLC59XXX_REG_GRPFREQ, 0x03 }, /* very fast blinking */
+	{ CLA_LED_CHIP_ADDR, TLC59XXX_REG_PWM(CLA_LED_STATUS_RED), 0x80 }, /* 50% brightness */
+	{ CLA_LED_CHIP_ADDR, TLC59XXX_REG_PWM(CLA_LED_STATUS_GREEN), 0x80 }, /* 50% brightness */
+	{ CLA_LED_CHIP_ADDR, TLC59XXX_REG_PWM(CLA_LED_STATUS_BLUE), 0x80 }, /* 50% brightness */
+	{ CLA_LED_CHIP_ADDR, TLC59XXX_REG_LEDOUT2, 0x3f }, /* LEDs #8, 9, 10: mode 0b11 -> group blinking */
+};
+
+int cla_setup_leds(void)
+{
+	if (i2c_set_bus_num(1)) {
+		puts("Cannot select I2C bus 1");
+		return 1;
+	}
+	for (int i = 0; i < ARRAY_SIZE(led_config); i++) {
+		if (i2c_write(led_config[i].chip, led_config[i].addr, 1, &led_config[i].val, 1)) {
+			printf("LED config operation %d failed\n", i);
+			return 1;
+		}
+	}
+	return 0;
+}
+
 int board_init(void)
 {
 	int i;
@@ -131,6 +184,18 @@ int board_init(void)
 	/* Address of boot parameters */
 	gd->bd->bi_boot_params = mvebu_sdram_bar(0) + 0x100;
 
+#ifndef CONFIG_SPL_BUILD
+# ifdef CONFIG_WDT_ORION
+        if (uclass_get_device(UCLASS_WDT, 0, &watchdog_dev)) {
+                puts("Cannot find Armada 385 watchdog!\n");
+        } else {
+                puts("Enabling Armada 385 watchdog.\n");
+		/* one minute */
+                wdt_start(watchdog_dev, (u32) 25000000 * 60, 0);
+        }
+# endif
+#endif
+
 	/* Toggle GPIO41 to reset onboard switch and phy */
 	clrbits_le32(MVEBU_GPIO1_BASE + 0x0, BIT(9));
 	clrbits_le32(MVEBU_GPIO1_BASE + 0x4, BIT(9));
@@ -146,9 +211,33 @@ int board_init(void)
 	for (i = 0; i < ARRAY_SIZE(io_exp); i++)
 		i2c_write(io_exp[i].chip, io_exp[i].addr, 1, &io_exp[i].val, 1);
 
+	cla_setup_leds();
+
 	return 0;
 }
 
+#ifdef CONFIG_WATCHDOG
+/* Called by macro WATCHDOG_RESET */
+void watchdog_reset(void)
+{
+# if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_WDT_ORION)
+        static ulong next_reset = 0;
+        ulong now;
+
+        if (!watchdog_dev)
+                return;
+
+        now = timer_get_us();
+
+        /* Do not reset the watchdog too often */
+        if (now > next_reset) {
+                wdt_reset(watchdog_dev);
+                next_reset = now + 1000;
+        }
+# endif
+}
+#endif
+
 int checkboard(void)
 {
 	puts("Board: SolidRun ClearFog\n");
diff --git a/configs/clearfog_defconfig b/configs/clearfog_defconfig
index 5e1733e11b..4af2d1e902 100644
--- a/configs/clearfog_defconfig
+++ b/configs/clearfog_defconfig
@@ -53,3 +53,5 @@ CONFIG_USB=y
 CONFIG_DM_USB=y
 CONFIG_USB_XHCI_HCD=y
 CONFIG_USB_STORAGE=y
+CONFIG_WDT=y
+CONFIG_WDT_ORION=y
diff --git a/include/configs/clearfog.h b/include/configs/clearfog.h
index f57f9b21ab..b2ed0d5594 100644
--- a/include/configs/clearfog.h
+++ b/include/configs/clearfog.h
@@ -25,8 +25,15 @@
 #define CONFIG_SYS_I2C
 #define CONFIG_SYS_I2C_MVTWSI
 #define CONFIG_I2C_MVTWSI_BASE0		MVEBU_TWSI_BASE
+#define CONFIG_I2C_MVTWSI_BASE1		MVEBU_TWSI1_BASE
 #define CONFIG_SYS_I2C_SLAVE		0x0
 #define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_EEPROM_SIZE		(128 * 1024)
+
+/* Watchdog */
+#if !defined(CONFIG_SPL_BUILD) && defined(CONFIG_WDT_ORION)
+# define CONFIG_WATCHDOG
+#endif
 
 /* SPI NOR flash default params, used by sf commands */
 #define CONFIG_SF_DEFAULT_BUS		1
@@ -54,6 +61,9 @@
 #define CONFIG_ENV_OFFSET		0xf0000
 #define CONFIG_ENV_ADDR			CONFIG_ENV_OFFSET
 
+#define CONFIG_ENV_OFFSET_REDUND	0xe0000
+#define CONFIG_SYS_REDUNDAND_ENVIRONMENT
+
 #define PHY_ANEG_TIMEOUT	8000	/* PHY needs a longer aneg time */
 
 /* PCIe support */
@@ -149,14 +159,45 @@
 	"scriptaddr=" SCRIPT_ADDR_R "\0" \
 	"pxefile_addr_r=" PXEFILE_ADDR_R "\0"
 
-#include <config_distro_bootcmd.h>
-
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	RELOCATION_LIMITS_ENV_SETTINGS \
 	LOAD_ADDRESS_ENV_SETTINGS \
-	"fdtfile=" CONFIG_DEFAULT_DEVICE_TREE ".dtb\0" \
 	"console=ttyS0,115200\0" \
-	BOOTENV
+	"usbboot=usb start; fatload usb 0:1 ${scriptaddr} boot.scr; source ${scriptaddr}\0" \
+	"bootcmd=test -n \"${BOOT_A_LEFT}\" || setenv BOOT_A_LEFT 3;" \
+	"test -n \"${BOOT_B_LEFT}\" || setenv BOOT_B_LEFT 3;" \
+	"test -n \"${BOOT_ORDER}\" || setenv BOOT_ORDER \"A B\";" \
+	"setenv rauc_part;" \
+	"for BOOT_SLOT in \"${BOOT_ORDER}\"; do" \
+	"  if test \"x${rauc_part}\" != \"x\"; then" \
+	"    ;" \
+	"  elif test \"x${BOOT_SLOT}\" = \"xA\"; then" \
+	"    if test ${BOOT_A_LEFT} -gt 0; then" \
+	"      setexpr BOOT_A_LEFT ${BOOT_A_LEFT} - 1;" \
+	"      echo \"Found valid slot A, ${BOOT_A_LEFT} attempts remaining\";" \
+	"      setenv rauc_part 1;" \
+	"      setenv rauc_slot A;" \
+	"    fi;" \
+	"  elif test \"x${BOOT_SLOT}\" = \"xB\"; then" \
+	"    if test ${BOOT_B_LEFT} -gt 0; then" \
+	"      setexpr BOOT_B_LEFT ${BOOT_B_LEFT} - 1;" \
+	"      echo \"Found valid slot B, ${BOOT_B_LEFT} attempts remaining\";" \
+	"      setenv rauc_part 3;" \
+	"      setenv rauc_slot B;" \
+	"    fi;" \
+	"  fi;" \
+	"done;" \
+	"if test -n \"${rauc_part}\"; then" \
+	"  saveenv ;" \
+	"else" \
+	"  echo \"No valid slot found, resetting tries to 3\";" \
+	"  setenv BOOT_A_LEFT 3;" \
+	"  setenv BOOT_B_LEFT 3;" \
+	"  saveenv;" \
+	"  reset;" \
+	"fi;" \
+	"load mmc 0:${rauc_part} ${scriptaddr} /boot/boot.scr || reset;" \
+	"source ${scriptaddr} || reset\0"
 
 #endif /* CONFIG_SPL_BUILD */
 
