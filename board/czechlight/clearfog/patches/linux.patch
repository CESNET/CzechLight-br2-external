diff --git a/Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt b/Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt
index 2fa5edac7a35..4906544628ec 100644
--- a/Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt
+++ b/Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt
@@ -146,3 +146,38 @@ gpio21: gpio@21 {
 		bias-pull-up;
 	};
 };
+
+Line naming
+===========
+
+Because several gpio_chip instances are hidden below a single device tree
+node, it is necessary to split the names into several child nodes. Ensure
+that the configured addresses match those in the microchip,spi-present-mask:
+
+gpio@0 {
+	compatible = "microchip,mcp23s17";
+	gpio-controller;
+	#gpio-cells = <2>;
+	/* this bitmask has bits #0 (0x01) and #2 (0x04) set */
+	spi-present-mask = <0x05>;
+	reg = <0>;
+	spi-max-frequency = <1000000>;
+
+	gpio-bank@1 {
+		address = <0>;
+		gpio-line-names =
+			"GPA0",
+			"GPA1",
+			...
+			"GPA7",
+			"GPB0",
+			"GPB1",
+			...
+			"GPB7";
+	};
+
+	gpio-bank@2 {
+		address = <2>;
+		gpio-line-names = ...
+	};
+};
diff --git a/arch/arm/boot/dts/armada-388-clearfog.dtsi b/arch/arm/boot/dts/armada-388-clearfog.dtsi
index f8a06ae4a3c9..8f32e05b6d87 100644
--- a/arch/arm/boot/dts/armada-388-clearfog.dtsi
+++ b/arch/arm/boot/dts/armada-388-clearfog.dtsi
@@ -196,8 +196,12 @@ &i2c1 {
 	 */
 	clock-frequency = <100000>;
 	pinctrl-0 = <&clearfog_i2c1_pins>;
-	pinctrl-names = "default";
+	pinctrl-1 = <&clearfog_i2c1_recovery_pins>;
+	pinctrl-names = "default", "gpio";
 	status = "okay";
+	single-master;
+	scl-gpios = <&gpio0 26 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+	sda-gpios = <&gpio0 27 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
 };
 
 &pinctrl {
@@ -206,6 +210,10 @@ clearfog_i2c1_pins: i2c1-pins {
 		marvell,pins = "mpp26", "mpp27";
 		marvell,function = "i2c1";
 	};
+	clearfog_i2c1_recovery_pins: i2c1-recovery-pins {
+		marvell,pins = "mpp26", "mpp27";
+		marvell,function = "gpio";
+	};
 	clearfog_sdhci_cd_pins: clearfog-sdhci-cd-pins {
 		marvell,pins = "mpp20";
 		marvell,function = "gpio";
diff --git a/drivers/leds/leds-tlc591xx.c b/drivers/leds/leds-tlc591xx.c
index cb7bd1353f9f..85865f1628d7 100644
--- a/drivers/leds/leds-tlc591xx.c
+++ b/drivers/leds/leds-tlc591xx.c
@@ -40,6 +40,9 @@
 
 #define ldev_to_led(c)		container_of(c, struct tlc591xx_led, ldev)
 
+#define TLC591XX_RESET_BYTE_0	0xa5
+#define TLC591XX_RESET_BYTE_1	0x5a
+
 struct tlc591xx_led {
 	bool active;
 	unsigned int led_no;
@@ -51,21 +54,25 @@ struct tlc591xx_priv {
 	struct tlc591xx_led leds[TLC591XX_MAX_LEDS];
 	struct regmap *regmap;
 	unsigned int reg_ledout_offset;
+	struct i2c_client *swrst_client;
 };
 
 struct tlc591xx {
 	unsigned int max_leds;
 	unsigned int reg_ledout_offset;
+	u8 swrst_addr;
 };
 
 static const struct tlc591xx tlc59116 = {
 	.max_leds = 16,
 	.reg_ledout_offset = 0x14,
+	.swrst_addr = 0x6b,
 };
 
 static const struct tlc591xx tlc59108 = {
 	.max_leds = 8,
 	.reg_ledout_offset = 0x0c,
+	.swrst_addr = 0x4b,
 };
 
 static int
@@ -180,6 +187,18 @@ tlc591xx_probe(struct i2c_client *client,
 
 	i2c_set_clientdata(client, priv);
 
+	priv->swrst_client = devm_i2c_new_dummy_device(dev, client->adapter, tlc591xx->swrst_addr);
+	if (IS_ERR(priv->swrst_client)) {
+		dev_info(dev, "Skipping reset: address %02x already used\n",
+				tlc591xx->swrst_addr);
+	} else {
+		err = i2c_smbus_write_byte_data(priv->swrst_client,
+				TLC591XX_RESET_BYTE_0, TLC591XX_RESET_BYTE_1);
+		if (err) {
+			dev_warn(dev, "SW reset failed\n");
+		}
+	}
+
 	err = tlc591xx_set_mode(priv->regmap, MODE2_DIM);
 	if (err < 0)
 		return err;
diff --git a/drivers/pinctrl/pinctrl-mcp23s08_spi.c b/drivers/pinctrl/pinctrl-mcp23s08_spi.c
index 9ae10318f6f3..d378369bbeca 100644
--- a/drivers/pinctrl/pinctrl-mcp23s08_spi.c
+++ b/drivers/pinctrl/pinctrl-mcp23s08_spi.c
@@ -8,6 +8,7 @@
 #include <linux/spi/spi.h>
 
 #include "pinctrl-mcp23s08.h"
+#include "../gpio/gpiolib.h"
 
 #define MCP_MAX_DEV_PER_CS	8
 
@@ -143,6 +144,10 @@ static int mcp23s08_probe(struct spi_device *spi)
 	int type;
 	int ret;
 	u32 v;
+	struct device_node *np;
+	int line_name_count;
+	const char **names;
+	int i;
 
 	match = device_get_match_data(dev);
 	if (match)
@@ -192,6 +197,43 @@ static int mcp23s08_probe(struct spi_device *spi)
 			return ret;
 
 		ngpio += data->mcp[addr]->chip.ngpio;
+
+		for_each_available_child_of_node(spi->dev.of_node, np) {
+			u32 chip_addr;
+			ret = of_property_read_u32(np, "address", &chip_addr);
+			if (ret)
+				continue;
+			if (chip_addr != addr)
+				continue;
+
+			line_name_count = fwnode_property_read_string_array(of_fwnode_handle(np), "gpio-line-names", NULL, 0);
+			if (line_name_count < 0)
+				continue;
+
+			if (line_name_count > data->mcp[addr]->chip.ngpio) {
+				dev_warn(&spi->dev, "gpio-line-names is length %d but should be at most length %d",
+					 line_name_count, data->mcp[addr]->chip.ngpio);
+				line_name_count = data->mcp[addr]->chip.ngpio;
+			}
+
+			names = kcalloc(line_name_count, sizeof(*names), GFP_KERNEL);
+			if (!names) {
+				dev_warn(&spi->dev, "cannot allocate gpio-line-names");
+				continue;
+			}
+
+			ret = fwnode_property_read_string_array(of_fwnode_handle(np), "gpio-line-names", names, line_name_count);
+			if (ret < 0) {
+				dev_warn(&spi->dev, "failed to read GPIO line names");
+				kfree(names);
+				continue;
+			}
+
+			for (i = 0; i < line_name_count; i++)
+				data->mcp[addr]->chip.gpiodev->descs[i].name = names[i];
+
+			kfree(names);
+		}
 	}
 	data->ngpio = ngpio;
 
diff --git a/drivers/spi/spi-orion.c b/drivers/spi/spi-orion.c
index 565cd4c48d7b..cb252d98184c 100644
--- a/drivers/spi/spi-orion.c
+++ b/drivers/spi/spi-orion.c
@@ -86,10 +86,6 @@ struct orion_direct_acc {
 	u32			size;
 };
 
-struct orion_child_options {
-	struct orion_direct_acc direct_access;
-};
-
 struct orion_spi {
 	struct spi_master	*master;
 	void __iomem		*base;
@@ -98,7 +94,7 @@ struct orion_spi {
 	const struct orion_spi_dev *devdata;
 	struct device		*dev;
 
-	struct orion_child_options	child[ORION_NUM_CHIPSELECTS];
+	struct orion_direct_acc	direct_access[ORION_NUM_CHIPSELECTS];
 };
 
 #ifdef CONFIG_PM
@@ -473,7 +469,7 @@ orion_spi_write_read(struct spi_device *spi, struct spi_transfer *xfer)
 	int cs = spi->chip_select;
 	void __iomem *vaddr;
 
-	word_len = spi->bits_per_word;
+	word_len = xfer->bits_per_word;
 	count = xfer->len;
 
 	orion_spi = spi_master_get_devdata(spi->master);
@@ -483,7 +479,7 @@ orion_spi_write_read(struct spi_device *spi, struct spi_transfer *xfer)
 	 * and SPI_CS_WORD flag is not set.
 	 * Otherwise fall back to PIO mode for this transfer.
 	 */
-	vaddr = orion_spi->child[cs].direct_access.vaddr;
+	vaddr = orion_spi->direct_access[cs].vaddr;
 
 	if (vaddr && xfer->tx_buf && word_len == 8 && (spi->mode & SPI_CS_WORD) == 0) {
 		unsigned int cnt = count / 4;
@@ -736,7 +732,6 @@ static int orion_spi_probe(struct platform_device *pdev)
 	}
 
 	for_each_available_child_of_node(pdev->dev.of_node, np) {
-		struct orion_direct_acc *dir_acc;
 		u32 cs;
 
 		/* Get chip-select number from the "reg" property */
@@ -765,14 +760,15 @@ static int orion_spi_probe(struct platform_device *pdev)
 		 * This needs to get extended for the direct SPI NOR / SPI NAND
 		 * support, once this gets implemented.
 		 */
-		dir_acc = &spi->child[cs].direct_access;
-		dir_acc->vaddr = devm_ioremap(&pdev->dev, r->start, PAGE_SIZE);
-		if (!dir_acc->vaddr) {
+		spi->direct_access[cs].vaddr = devm_ioremap(&pdev->dev,
+							    r->start,
+							    PAGE_SIZE);
+		if (!spi->direct_access[cs].vaddr) {
 			status = -ENOMEM;
 			of_node_put(np);
 			goto out_rel_axi_clk;
 		}
-		dir_acc->size = PAGE_SIZE;
+		spi->direct_access[cs].size = PAGE_SIZE;
 
 		dev_info(&pdev->dev, "CS%d configured for direct access\n", cs);
 	}
diff --git a/drivers/tty/serial/max310x.c b/drivers/tty/serial/max310x.c
index fbf6e2b3161c..eca377a784a0 100644
--- a/drivers/tty/serial/max310x.c
+++ b/drivers/tty/serial/max310x.c
@@ -237,6 +237,10 @@
 #define MAX310x_REV_MASK		(0xf8)
 #define MAX310X_WRITE_BIT		0x80
 
+/* Timeout for external crystal stability */
+#define MAX310X_XTAL_WAIT_RETRIES	20
+#define MAX310X_XTAL_WAIT_DELAY_MS	10
+
 /* MAX3107 specific */
 #define MAX3107_REV_ID			(0xa0)
 
@@ -636,11 +640,14 @@ static u32 max310x_set_ref_clk(struct device *dev, struct max310x_port *s,
 
 	/* Wait for crystal */
 	if (xtal) {
-		unsigned int val;
-		msleep(10);
-		regmap_read(s->regmap, MAX310X_STS_IRQSTS_REG, &val);
+		unsigned int val = 0, i;
+		for (i = 0; i < MAX310X_XTAL_WAIT_RETRIES && !(val & MAX310X_STS_CLKREADY_BIT); ++i) {
+			msleep(MAX310X_XTAL_WAIT_DELAY_MS);
+			regmap_read(s->regmap, MAX310X_STS_IRQSTS_REG, &val);
+		}
 		if (!(val & MAX310X_STS_CLKREADY_BIT)) {
-			dev_warn(dev, "clock is not stable yet\n");
+			dev_err(dev, "clock is not stable\n");
+			return -EAGAIN;
 		}
 	}
 
@@ -1347,6 +1354,10 @@ static int max310x_probe(struct device *dev, const struct max310x_devtype *devty
 	}
 
 	uartclk = max310x_set_ref_clk(dev, s, freq, xtal);
+	if (uartclk < 0) {
+		ret = uartclk;
+		goto out_uart;
+	}
 	dev_dbg(dev, "Reference clock set to %i Hz\n", uartclk);
 
 	for (i = 0; i < devtype->nr; i++) {
