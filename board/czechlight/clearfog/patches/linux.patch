diff --git a/Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt b/Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt
index 2fa5edac7a35..4906544628ec 100644
--- a/Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt
+++ b/Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt
@@ -146,3 +146,38 @@ gpio21: gpio@21 {
 		bias-pull-up;
 	};
 };
+
+Line naming
+===========
+
+Because several gpio_chip instances are hidden below a single device tree
+node, it is necessary to split the names into several child nodes. Ensure
+that the configured addresses match those in the microchip,spi-present-mask:
+
+gpio@0 {
+	compatible = "microchip,mcp23s17";
+	gpio-controller;
+	#gpio-cells = <2>;
+	/* this bitmask has bits #0 (0x01) and #2 (0x04) set */
+	spi-present-mask = <0x05>;
+	reg = <0>;
+	spi-max-frequency = <1000000>;
+
+	gpio-bank@1 {
+		address = <0>;
+		gpio-line-names =
+			"GPA0",
+			"GPA1",
+			...
+			"GPA7",
+			"GPB0",
+			"GPB1",
+			...
+			"GPB7";
+	};
+
+	gpio-bank@2 {
+		address = <2>;
+		gpio-line-names = ...
+	};
+};
diff --git a/arch/arm/boot/dts/armada-388-clearfog.dtsi b/arch/arm/boot/dts/armada-388-clearfog.dtsi
index f8a06ae4a3c9..8f32e05b6d87 100644
--- a/arch/arm/boot/dts/armada-388-clearfog.dtsi
+++ b/arch/arm/boot/dts/armada-388-clearfog.dtsi
@@ -196,8 +196,12 @@ &i2c1 {
 	 */
 	clock-frequency = <100000>;
 	pinctrl-0 = <&clearfog_i2c1_pins>;
-	pinctrl-names = "default";
+	pinctrl-1 = <&clearfog_i2c1_recovery_pins>;
+	pinctrl-names = "default", "gpio";
 	status = "okay";
+	single-master;
+	scl-gpios = <&gpio0 26 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+	sda-gpios = <&gpio0 27 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
 };
 
 &pinctrl {
@@ -206,6 +210,10 @@ clearfog_i2c1_pins: i2c1-pins {
 		marvell,pins = "mpp26", "mpp27";
 		marvell,function = "i2c1";
 	};
+	clearfog_i2c1_recovery_pins: i2c1-recovery-pins {
+		marvell,pins = "mpp26", "mpp27";
+		marvell,function = "gpio";
+	};
 	clearfog_sdhci_cd_pins: clearfog-sdhci-cd-pins {
 		marvell,pins = "mpp20";
 		marvell,function = "gpio";
diff --git a/drivers/leds/leds-tlc591xx.c b/drivers/leds/leds-tlc591xx.c
index 7e31db50036f..ec00a93122bb 100644
--- a/drivers/leds/leds-tlc591xx.c
+++ b/drivers/leds/leds-tlc591xx.c
@@ -40,6 +40,9 @@
 
 #define ldev_to_led(c)		container_of(c, struct tlc591xx_led, ldev)
 
+#define TLC591XX_RESET_BYTE_0	0xa5
+#define TLC591XX_RESET_BYTE_1	0x5a
+
 struct tlc591xx_led {
 	bool active;
 	unsigned int led_no;
@@ -51,21 +54,25 @@ struct tlc591xx_priv {
 	struct tlc591xx_led leds[TLC591XX_MAX_LEDS];
 	struct regmap *regmap;
 	unsigned int reg_ledout_offset;
+	struct i2c_client *swrst_client;
 };
 
 struct tlc591xx {
 	unsigned int max_leds;
 	unsigned int reg_ledout_offset;
+	u8 swrst_addr;
 };
 
 static const struct tlc591xx tlc59116 = {
 	.max_leds = 16,
 	.reg_ledout_offset = 0x14,
+	.swrst_addr = 0x6b,
 };
 
 static const struct tlc591xx tlc59108 = {
 	.max_leds = 8,
 	.reg_ledout_offset = 0x0c,
+	.swrst_addr = 0x4b,
 };
 
 static int
@@ -179,6 +186,18 @@ tlc591xx_probe(struct i2c_client *client)
 
 	i2c_set_clientdata(client, priv);
 
+	priv->swrst_client = devm_i2c_new_dummy_device(dev, client->adapter, tlc591xx->swrst_addr);
+	if (IS_ERR(priv->swrst_client)) {
+		dev_info(dev, "Skipping reset: address %02x already used\n",
+				tlc591xx->swrst_addr);
+	} else {
+		err = i2c_smbus_write_byte_data(priv->swrst_client,
+				TLC591XX_RESET_BYTE_0, TLC591XX_RESET_BYTE_1);
+		if (err) {
+			dev_warn(dev, "SW reset failed\n");
+		}
+	}
+
 	err = tlc591xx_set_mode(priv->regmap, MODE2_DIM);
 	if (err < 0)
 		return err;
diff --git a/drivers/leds/trigger/Kconfig b/drivers/leds/trigger/Kconfig
index 2a57328eca20..dc6816d36d06 100644
--- a/drivers/leds/trigger/Kconfig
+++ b/drivers/leds/trigger/Kconfig
@@ -83,7 +83,6 @@ config LEDS_TRIGGER_ACTIVITY
 config LEDS_TRIGGER_GPIO
 	tristate "LED GPIO Trigger"
 	depends on GPIOLIB || COMPILE_TEST
-	depends on BROKEN
 	help
 	  This allows LEDs to be controlled by gpio events. It's good
 	  when using gpios as switches and triggering the needed LEDs
diff --git a/drivers/pinctrl/pinctrl-mcp23s08_spi.c b/drivers/pinctrl/pinctrl-mcp23s08_spi.c
index 9ae10318f6f3..d378369bbeca 100644
--- a/drivers/pinctrl/pinctrl-mcp23s08_spi.c
+++ b/drivers/pinctrl/pinctrl-mcp23s08_spi.c
@@ -8,6 +8,7 @@
 #include <linux/spi/spi.h>
 
 #include "pinctrl-mcp23s08.h"
+#include "../gpio/gpiolib.h"
 
 #define MCP_MAX_DEV_PER_CS	8
 
@@ -143,6 +144,10 @@ static int mcp23s08_probe(struct spi_device *spi)
 	int type;
 	int ret;
 	u32 v;
+	struct device_node *np;
+	int line_name_count;
+	const char **names;
+	int i;
 
 	match = device_get_match_data(dev);
 	if (match)
@@ -192,6 +197,43 @@ static int mcp23s08_probe(struct spi_device *spi)
 			return ret;
 
 		ngpio += data->mcp[addr]->chip.ngpio;
+
+		for_each_available_child_of_node(spi->dev.of_node, np) {
+			u32 chip_addr;
+			ret = of_property_read_u32(np, "address", &chip_addr);
+			if (ret)
+				continue;
+			if (chip_addr != addr)
+				continue;
+
+			line_name_count = fwnode_property_read_string_array(of_fwnode_handle(np), "gpio-line-names", NULL, 0);
+			if (line_name_count < 0)
+				continue;
+
+			if (line_name_count > data->mcp[addr]->chip.ngpio) {
+				dev_warn(&spi->dev, "gpio-line-names is length %d but should be at most length %d",
+					 line_name_count, data->mcp[addr]->chip.ngpio);
+				line_name_count = data->mcp[addr]->chip.ngpio;
+			}
+
+			names = kcalloc(line_name_count, sizeof(*names), GFP_KERNEL);
+			if (!names) {
+				dev_warn(&spi->dev, "cannot allocate gpio-line-names");
+				continue;
+			}
+
+			ret = fwnode_property_read_string_array(of_fwnode_handle(np), "gpio-line-names", names, line_name_count);
+			if (ret < 0) {
+				dev_warn(&spi->dev, "failed to read GPIO line names");
+				kfree(names);
+				continue;
+			}
+
+			for (i = 0; i < line_name_count; i++)
+				data->mcp[addr]->chip.gpiodev->descs[i].name = names[i];
+
+			kfree(names);
+		}
 	}
 	data->ngpio = ngpio;
 
diff --git a/drivers/spi/spi-orion.c b/drivers/spi/spi-orion.c
index ad9e83e34297..dc5c60182ea5 100644
--- a/drivers/spi/spi-orion.c
+++ b/drivers/spi/spi-orion.c
@@ -473,7 +473,7 @@ orion_spi_write_read(struct spi_device *spi, struct spi_transfer *xfer)
 	int cs = spi_get_chipselect(spi, 0);
 	void __iomem *vaddr;
 
-	word_len = spi->bits_per_word;
+	word_len = xfer->bits_per_word;
 	count = xfer->len;
 
 	orion_spi = spi_master_get_devdata(spi->master);
diff --git a/drivers/tty/serial/max310x.c b/drivers/tty/serial/max310x.c
index 9fee722058f4..2a9d2a6a7b31 100644
--- a/drivers/tty/serial/max310x.c
+++ b/drivers/tty/serial/max310x.c
@@ -237,6 +237,10 @@
 #define MAX310x_REV_MASK		(0xf8)
 #define MAX310X_WRITE_BIT		0x80
 
+/* Timeout for external crystal stability */
+#define MAX310X_XTAL_WAIT_RETRIES	20
+#define MAX310X_XTAL_WAIT_DELAY_MS	10
+
 /* MAX3107 specific */
 #define MAX3107_REV_ID			(0xa0)
 
@@ -641,11 +645,14 @@ static u32 max310x_set_ref_clk(struct device *dev, struct max310x_port *s,
 
 	/* Wait for crystal */
 	if (xtal) {
-		unsigned int val;
-		msleep(10);
-		regmap_read(s->regmap, MAX310X_STS_IRQSTS_REG, &val);
+		unsigned int val = 0, i;
+		for (i = 0; i < MAX310X_XTAL_WAIT_RETRIES && !(val & MAX310X_STS_CLKREADY_BIT); ++i) {
+			msleep(MAX310X_XTAL_WAIT_DELAY_MS);
+			regmap_read(s->regmap, MAX310X_STS_IRQSTS_REG, &val);
+		}
 		if (!(val & MAX310X_STS_CLKREADY_BIT)) {
-			dev_warn(dev, "clock is not stable yet\n");
+			dev_err(dev, "clock is not stable\n");
+			return -EAGAIN;
 		}
 	}
 
@@ -1348,6 +1355,10 @@ static int max310x_probe(struct device *dev, const struct max310x_devtype *devty
 	}
 
 	uartclk = max310x_set_ref_clk(dev, s, freq, xtal);
+	if (uartclk < 0) {
+		ret = uartclk;
+		goto out_uart;
+	}
 	dev_dbg(dev, "Reference clock set to %i Hz\n", uartclk);
 
 	for (i = 0; i < devtype->nr; i++) {
