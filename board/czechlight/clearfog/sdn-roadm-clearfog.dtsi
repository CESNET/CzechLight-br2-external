#include "armada-388-clearfog-base.dts"

&w25q32 {
	status = "okay";
};

/ {
	clocks {
		spi_uart_clk: osc_max14830 {
			compatible = "fixed-clock";
			#clock-cells = <0>;
			clock-frequency = <3686400>;
		};
	};

	soc {
		internal-regs {
			sdhci@d8000 {
				/delete-property/ cd-gpios;
				broken-cd;
			};
		};
	};

	gpio_i2c: gpio_i2c {
		compatible = "i2c-gpio";
		sda-gpios = <&gpio0 25 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		scl-gpios = <&gpio0 24 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		i2c-gpio.delay-us = <1>;
		#address-cells = <1>;
		#size-cells = <0>;
		pinctrl-names = "default";
		pinctrl-0 = <&uart1_pins_i2c_bb>;
	};
};

&gpio_i2c {
	pdu@25 {
		compatible = "fsp,yh5151e";
		reg = <0x25>;
	};
};

&pinctrl {
	uart1_pins_i2c_bb: uart1-pins-i2c-bb {
		marvell,pins = "mpp24", "mpp25";
		marvell,function = "gpio";
	};

	clearfog_i2c1_recovery_pins: clearfog-i2c1-recovery-pins {
		marvell,pins = "mpp26", "mpp27";
		marvell,function = "gpio";
	};
};

&mikro_uart_pins {
	status = "disabled";
};

&uart1 {
	status = "disabled";
};

&gpio1 {
	spi_int {
		/* MPP54: this needs an external pull-up */
		gpio-hog;
		gpios = <22 GPIO_ACTIVE_HIGH>;
		input;
		line-name = "SPI-INT";
	};
};

&spi1 {
	cs-gpios = <0>, <&gpio0 22 GPIO_ACTIVE_HIGH>, <0>, <&gpio0 29 GPIO_ACTIVE_HIGH>;

	max14830: max14830@2 {
		compatible = "maxim,max14830";
		reg = <2>;
		clocks = <&spi_uart_clk>;
		clock-names = "xtal";
		interrupt-parent = <&gpio1>;
		interrupts = <22 IRQ_TYPE_LEVEL_LOW>;
		gpio-controller;
		#gpio-cells = <2>;
		spi-max-frequency = <26000000>;

		gpio-line-names =
			"WSS_HWRST",
			"WSS_SSD",
			"OCM_HS_IN",
			"OCM_RESET",
			"WSS_MRST",
#ifdef CLEARFOG_REV1
			"I2C_XOR_ENABLE",
			"I2C_XORH",
			"I2C_BB_ENABLE",
			"GPIO_K6",
#else

			"",
			"",
			"",
			"",
#endif
			"",
			"",
			"EDFA1_AMP_DISABLE",
			"EDFA2_AMP_DISABLE",
			"EDFA1_OUT_POWER_MUTE",
			"EDFA2_OUT_POWER_MUTE",
			"EXP_GPIO1"
			;

#ifdef CLEARFOG_REV1
		i2c_bitbang_enable {
			gpio-hog;
			gpios = <7 GPIO_ACTIVE_HIGH>;
			output-high;
			line-name = "I2C bitbang bus";
		};

		i2c_xor_high {
			gpio-hog;
			gpios = <6 GPIO_ACTIVE_HIGH>;
			output-high; // XOR byte 0b1001111
			line-name = "I2C XOR high";
		};

		i2c_xor_enable {
			gpio-hog;
			gpios = <5 GPIO_ACTIVE_HIGH>;
			output-low;
			line-name = "I2C addr xlate";
		};
#endif
	};

	gpio_spi_chips: gpio@1 {
		compatible = "microchip,mcp23s17";
		reg = <1>;
		interrupt-parent = <&gpio1>;
		interrupts = <22 IRQ_TYPE_LEVEL_LOW>;
		interrupt-controller;
		#interrupt-cells = <2>;
		gpio-controller;
		#gpio-cells = <2>;
		microchip,spi-present-mask = <0x06>; /* extra addresses 1 and 2 */
		microchip,irq-mirror;
		drive-open-drain;
		spi-max-frequency = <10000000>;

		// FIXME: this naming is incompatible with that hack which makes these devices visible as 2*16pin standalone chips
		gpio-bank@1 {
			address = <1>;
			gpio-line-names =
				"EDFA1_RESET",
				"EDFA2_RESET",
				"PMB_ALERT",
#ifdef CLEARFOG_REV1
				"EXP_GPIO2",
#else
				"GND",
#endif
				"WSS_SC",
				"WSS_RST",
#ifdef CLEARFOG_REV1
				"I2C_XOR_RDY",
#else
				"GND",
#endif
				"OCM_HS_OUT",

				"EDFA1_OUT_REFLECT_A",
				"EDFA1_PUMP_CURRENT_A",
				"EDFA1_ST1_IN_LOS_A",
				"EDFA1_ST2_IN_LOS_A",
				"EDFA1_ST2_OUT_GAIN_A",
				"EDFA1_CASE_TEMP_A",
				"EDFA1_ST1_OUT_GAIN_A",
				"EDFA1_PUMP_TEMP_A";
		};

		gpio-bank@2 {
			address = <2>;
			gpio-line-names =
#ifdef CLEARFOG_REV1
				"GND",
				"GND",
#else
				"OCM_READY",
				"OCM_ALARM",
#endif
				"GND",
				"GND",
				"GND",
				"GND",
				"GND",
				"GND",

				"EDFA2_OUT_REFLECT_A",
				"EDFA2_PUMP_CURRENT_A",
				"EDFA2_ST1_IN_LOS_A",
				"EDFA2_ST2_IN_LOS_A",
				"EDFA2_ST2_OUT_GAIN_A",
				"EDFA2_CASE_TEMP_A",
				"EDFA2_ST1_OUT_GAIN_A",
				"EDFA2_PUMP_TEMP_A";
		};

#ifdef CLEARFOG_REV1
		// FIXME: this hogs both .1 and .2 chips' #6 pin...
		i2c_xor_ready {
			gpio-hog;
			gpios = <6 GPIO_ACTIVE_HIGH>;
			input;
			line-name = "I2C XOR ready";
		};
#endif
	};

	lumentum_ocm: lumentum-ocm@3 {
		compatible = "lumentum-ocm";
		reg = <3>;
		spi-max-frequency = <12000000>;
		// The SPI slave is CPOL=1, but the rest of the devices is CPOL=0 and our SPI master
		// appears to have troubles with CPOL=1 toggling -> let's use a physical inverter
	};
};

&i2c1 {
	pinctrl-names = "default", "gpio";
	pinctrl-1 = <&clearfog_i2c1_recovery_pins>;
	single-master;
	scl-gpios = <&gpio0 26 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
	sda-gpios = <&gpio0 27 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;

#ifdef CLEARFOG_REV1
	eeprom@53 {
		compatible = "atmel,24c128";
		reg = <0x53>;
		pagesize = <64>;
		// There's no read-only parameter because we want to enable flashing the EEPROM by
		// installing a physical jumper. It doesn't matter that Linux still considers this
		// device as writable during normal operation because any write fill fail anyway
		// on the HW level. At least we can install that jumper and make the writes pass
		// magically without fiddling with the DT and rebooting.
	};
#else
	temperature@48 {
		compatible = "ti,tmp175";
		reg = <0x48>;
	};

	// 24CSxx is treated as two separate devices
	eeprom@53 {
		compatible = "atmel,24c64";
		reg = <0x53>;
	};
	eeprom@5b {
		compatible = "atmel,24cs64";
		reg = <0x5b>;
	};
#endif

	tlc59116@60 {
		#address-cells = <1>;
		#size-cells = <0>;
		#gpio-cells = <2>;
		compatible = "ti,tlc59116";
		reg = <0x60>;

		sfp_red@0 {
			label = "sfp:red";
			reg = <0>;
		};

		sfp_green@1 {
			label = "sfp:green";
			reg = <1>;
		};

		sfp_blue@2 {
			label = "sfp:blue";
			reg = <2>;
		};

		// OUT3 remains unused

		line_red@4 {
			label = "line:red";
			reg = <4>;
		};

		line_green@5 {
			label = "line:green";
			reg = <5>;
		};

		line_blue@6 {
			label = "line:blue";
			reg = <6>;
		};

		led5_red@7 {
			label = "led5:red";
			reg = <7>;
		};

		status_red@8 {
			label = "status:red";
			reg = <8>;
		};

		status_green@9 {
			label = "status:green";
			reg = <9>;
			linux,default-trigger = "timer";
		};

		status_blue@10 {
			label = "status:blue";
			reg = <10>;
		};

		led5_green@11 {
			label = "led5:green";
			reg = <11>;
		};

		uid_red@12 {
			label = "uid:red";
			reg = <12>;
		};

		uid_green@13 {
			label = "uid:green";
			reg = <13>;
		};

		uid_blue@14 {
			label = "uid:blue";
			reg = <14>;
		};

		led5_blue@15 {
			label = "led5:blue";
			reg = <15>;
		};
	};

#ifdef CLEARFOG_REV1
	/* ADT7463: it doesn't use the DT */
#else
	temperature@49 {
		compatible = "ti,tmp175";
		reg = <0x49>;
	};

	fancontrol@20 {
		compatible = "maxim,max31790";
		reg = <0x20>;
	};

	// 24CSxx is treated as two separate devices
	eeprom@54 {
		compatible = "atmel,24c64";
		reg = <0x54>;
	};
	eeprom@5c {
		compatible = "atmel,24cs64";
		reg = <0x5c>;
	};
#endif
};
