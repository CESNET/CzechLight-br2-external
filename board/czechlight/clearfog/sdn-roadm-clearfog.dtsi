#include "armada-388-clearfog-base.dts"

&w25q32 {
	status = "okay";
};

#undef CLEARFOG_PMBUS_BITBANG
#define IFACE_V_1_0 // v1.0, a first prototype
//#undef IFACE_V_1_0 // v1.0.1, the second iteration

#define BYPASS_SFP_PHYLINK

/ {
	clocks {
		spi_uart_clk: osc_max14830 {
			compatible = "fixed-clock";
			#clock-cells = <0>;
			clock-frequency = <3686400>;
		};
	};

	soc {
		internal-regs {
			sdhci@d8000 {
				/delete-property/ cd-gpios;
				broken-cd;
			};
		};
	};

#ifdef CLEARFOG_PMBUS_BITBANG
	gpio_i2c {
		compatible = "i2c-gpio";
		sda-gpios = <&gpio0 25 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		scl-gpios = <&gpio0 24 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
		i2c-gpio.delay-us = <1>;
		#address-cells = <1>;
		#size-cells = <0>;
	};
#endif

	gpio-leds {
		compatible = "gpio-leds";

		ok_led {
			label = "status-ok";
			linux,default-trigger = "default-on";
#ifdef IFACE_V_1_0
			gpios = <&max14830 9 GPIO_ACTIVE_HIGH>;
#else
			gpios = <&max14830 8 (GPIO_ACTIVE_LOW | GPIO_OPEN_DRAIN)>;
#endif
		};

		fail_led {
			label = "status-error";
			panic-indicator;
#ifdef IFACE_V_1_0
			gpios = <&max14830 8 GPIO_ACTIVE_HIGH>;
#else
			gpios = <&max14830 9 (GPIO_ACTIVE_LOW | GPIO_OPEN_DRAIN)>;
#endif
		};

		uid_led {
			label = "UID";
			linux,default-trigger = "heartbeat";
#ifdef IFACE_V_1_0
			gpios = <&max14830 10 GPIO_ACTIVE_HIGH>;
#else
			gpios = <&max14830 10 (GPIO_ACTIVE_LOW | GPIO_OPEN_DRAIN)>;
#endif
		};
	};
};

#ifdef CLEARFOG_PMBUS_BITBANG
&uart1_pins {
	status = "disabled";
};

&uart1 {
	status = "disabled";
};
#endif

&gpio1 {
	spi_int {
		/* MPP54: this needs an external pull-up */
		gpio-hog;
		gpios = <22 GPIO_ACTIVE_HIGH>;
		input;
		line-name = "SPI-INT";
	};
};

&spi1 {
	cs-gpios = <0>, <&gpio0 22 GPIO_ACTIVE_HIGH>, <0>, <&gpio0 29 GPIO_ACTIVE_HIGH>;

	max14830: max14830@2 {
		compatible = "maxim,max14830";
		reg = <2>;
		clocks = <&spi_uart_clk>;
		clock-names = "xtal";
		interrupt-parent = <&gpio1>;
		interrupts = <22 IRQ_TYPE_LEVEL_LOW>;
		gpio-controller;
		#gpio-cells = <2>;
		spi-max-frequency = <26000000>;

		gpio-line-names =
			"WSS_HWRST",
			"WSS_SSD",
			"OCM_HS_IN",
			"OCM_RESET",
			"WSS_MRST",
			"I2C_XOR_ENABLE",
			"I2C_XORH",
			"I2C_BB_ENABLE",
			"LED_RED",
			"LED_GREEN",
			"LED_BLUE",
			"EDFA1_AMP_DISABLE",
			"EDFA2_AMP_DISABLE",
			"EDFA1_OUT_POWER_MUTE",
			"EDFA2_OUT_POWER_MUTE",
#ifdef IFACE_V_1_0
			"" /* not used, not routed anywhere */
#else
			"EXP_GPIO1"
#endif
			;

		i2c_bitbang_enable {
			gpio-hog;
			gpios = <7 GPIO_ACTIVE_HIGH>;
#ifdef CLEARFOG_PMBUS_BITBANG
			output-high;
#else
			output-low;
#endif
			line-name = "I2C bitbang bus";
		};

		i2c_xor_high {
			gpio-hog;
			gpios = <6 GPIO_ACTIVE_HIGH>;
			//output-low;  // XOR byte 0b0001111
			output-high; // XOR byte 0b1101111
			line-name = "I2C XOR high";
		};

		i2c_xor_enable {
			gpio-hog;
			gpios = <5 GPIO_ACTIVE_HIGH>;
#ifdef CLEARFOG_PMBUS_BITBANG
			output-low;
#else
			output-high;
#endif
			line-name = "I2C addr xlate";
		};
	};

	gpio_spi_chips: gpio@1 {
		compatible = "microchip,mcp23s17";
		reg = <1>;
		interrupt-parent = <&gpio1>;
		interrupts = <22 IRQ_TYPE_LEVEL_LOW>;
		interrupt-controller;
		#interrupt-cells = <2>;
		gpio-controller;
		#gpio-cells = <2>;
		microchip,spi-present-mask = <0x06>; /* extra addresses 1 and 2 */
		microchip,irq-mirror;
		drive-open-drain;
		spi-max-frequency = <10000000>;

		// FIXME: this naming is incompatible with that hack which makes these devices visible as 2*16pin standalone chips
		gpio-bank@1 {
			address = <1>;
			gpio-line-names =
				"EDFA1_RESET",
				"EDFA2_RESET",
				"PMB_ALERT",
#ifdef IFACE_V_1_0
				"ATX_TTL",
#else
				"EXP_GPIO2",
#endif
				"WSS_SC",
				"WSS_RST",
				"I2C_XOR_RDY",
				"OCM_HS_OUT",

				"EDFA1_OUT_REFLECT_A",
				"EDFA1_PUMP_CURRENT_A",
				"EDFA1_ST1_IN_LOS_A",
				"EDFA1_ST2_IN_LOS_A",
				"EDFA1_ST2_OUT_GAIN_A",
				"EDFA1_CASE_TEMP_A",
				"EDFA1_ST1_OUT_GAIN_A",
				"EDFA1_PUMP_TEMP_A";
		};

		gpio-bank@2 {
			address = <2>;
			gpio-line-names =
				/* these are all grounded */
				"GND",
				"GND",
				"GND",
				"GND",
				"GND",
				"GND",
				"GND",
				"GND",

				"EDFA2_OUT_REFLECT_A",
				"EDFA2_PUMP_CURRENT_A",
				"EDFA2_ST1_IN_LOS_A",
				"EDFA2_ST2_IN_LOS_A",
				"EDFA2_ST2_OUT_GAIN_A",
				"EDFA2_CASE_TEMP_A",
				"EDFA2_ST1_OUT_GAIN_A",
				"EDFA2_PUMP_TEMP_A";
		};
	};

	spidev@3 {
		compatible = "spidev";
		reg = <3>;
		spi-max-frequency = <12000000>;
		// The SPI slave is CPOL=1, but the rest of the devices is CPOL=0 and our SPI master
		// appears to have troubles with CPOL=1 toggling -> let's use a physical inverter
		linux,spi-wdelay = /bits/ 16 <3>;
	};
};

&i2c1 {
	eeprom@53 {
		compatible = "atmel,24c128";
		reg = <0x53>;
		pagesize = <64>;
		// There's no read-only parameter because we want to enable flashing the EEPROM by
		// installing a physical jumper. It doesn't matter that Linux still considers this
		// device as writable during normal operation because any write fill fail anyway
		// on the HW level. At least we can install that jumper and make the writes pass
		// magically without fiddling with the DT and rebooting.
	};

	/* ADT7463: it doesn't use the DT */

#ifndef CLEARFOG_PMBUS_BITBANG
	/* TODO: pmbus, but that needs a disabled PEC... */
#endif
};

#ifdef BYPASS_SFP_PHYLINK

&sfp {
	state = "disabled";
};

&eth1 {
	/delete-property/ managed;
	/delete-property/ sfp;

	fixed-link {
		speed = <100>;
		full-duplex;
	};
};

&expander0 {
	sfp_los {
		/* SFP loss of signal */
		gpio-hog;
		gpios = <12 GPIO_ACTIVE_HIGH>;
		input;
		line-name = "sfp-los";
	};
	sfp_tx_fault {
		/* SFP laser fault */
		gpio-hog;
		gpios = <13 GPIO_ACTIVE_HIGH>;
		input;
		line-name = "sfp-tx-fault";
	};
	sfp_tx_disable {
		/* SFP transmit disable */
		gpio-hog;
		gpios = <14 GPIO_ACTIVE_HIGH>;
		output-low;
		line-name = "sfp-tx-disable";
	};
	sfp_mod_def0 {
		/* SFP module present */
		gpio-hog;
		gpios = <15 GPIO_ACTIVE_LOW>;
		input;
		line-name = "sfp-mod-def0";
	};
};

#endif
